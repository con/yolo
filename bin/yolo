#!/bin/bash
# Claude Code YOLO mode - auto-approve all actions in containerized environment

set -e

show_help() {
    cat << 'EOF'
Usage: yolo [OPTIONS] [-- CLAUDE_ARGS...]

Run Claude Code in YOLO mode (auto-approve all actions) inside a container.

OPTIONS:
    -h, --help          Show this help message
    --anonymized-paths  Use anonymized paths (/claude, /workspace) instead of
                        preserving host paths
    --entrypoint=CMD    Override the container entrypoint (default: claude)
    --worktree=MODE     Git worktree handling: ask, bind, skip, error
                        (default: ask)
    --nvidia            Enable NVIDIA GPU passthrough via CDI
                        Requires nvidia-container-toolkit on host
    --no-config         Ignore project configuration file

    Additional podman options can be passed before --

EXAMPLES:
    yolo                              # Basic usage
    yolo --nvidia                     # With GPU support
    yolo -v /data:/data               # Extra mount
    yolo -- "help with this code"     # Pass args to claude
    yolo --nvidia -- --resume         # GPU + claude args

NVIDIA GPU SETUP:
    The --nvidia flag uses CDI (Container Device Interface) for GPU access.
    Prerequisites:
    1. Install nvidia-container-toolkit on your host
    2. Generate CDI spec: sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml
    3. Use: yolo --nvidia

PROJECT CONFIGURATION:
    You can create a configuration file at .git/yolo/config to set default
    options for the project. This file supports:
    - PODMAN_VOLUME: Volume mounts (can be specified multiple times)
    - PODMAN_OPTION: Additional podman options (can be specified multiple times)
    - CLAUDE_ARG: Arguments for claude (can be specified multiple times)
    - ANONYMIZED_PATHS: Set to 1 to use anonymized paths by default
    - USE_NVIDIA: Set to 1 to enable NVIDIA GPU by default
    - WORKTREE_MODE: Set default worktree mode (ask/bind/skip/error)

    See .git/yolo/config.example for a complete example.
    Command line options always override config file settings.

EOF
    exit 0
}

# Function to find the .git directory
find_git_dir() {
    local current_dir="$(pwd)"
    
    while [ "$current_dir" != "/" ]; do
        if [ -d "$current_dir/.git" ]; then
            echo "$current_dir/.git"
            return 0
        elif [ -f "$current_dir/.git" ]; then
            # .git is a file (worktree), read gitdir path
            local gitdir_line=$(cat "$current_dir/.git")
            if [[ "$gitdir_line" =~ ^gitdir:\ (.+)$ ]]; then
                local gitdir_path="${BASH_REMATCH[1]}"
                # Resolve to absolute path if relative
                if [[ "$gitdir_path" != /* ]]; then
                    gitdir_path="$current_dir/$gitdir_path"
                fi
                # For worktrees, gitdir points to .git/worktrees/<name>
                # We want the main .git directory
                if [[ "$gitdir_path" =~ ^(.+/\.git)/worktrees/ ]]; then
                    echo "${BASH_REMATCH[1]}"
                    return 0
                fi
            fi
        fi
        current_dir="$(dirname "$current_dir")"
    done
    
    return 1
}

# Function to load configuration from .git/yolo/config
load_config() {
    local config_file="$1"
    
    if [ ! -f "$config_file" ]; then
        return 0
    fi
    
    # Read config file line by line
    while IFS='=' read -r key value; do
        # Skip comments and empty lines
        [[ "$key" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$key" ]] && continue
        
        # Trim whitespace
        key=$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        value=$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        # Skip if value is empty or commented out
        [[ -z "$value" ]] && continue
        
        # Expand ~ in value to $HOME
        value="${value/#\~/$HOME}"
        
        case "$key" in
            PODMAN_VOLUME)
                CONFIG_PODMAN_VOLUMES+=("$value")
                ;;
            PODMAN_OPTION)
                CONFIG_PODMAN_OPTIONS+=("$value")
                ;;
            CLAUDE_ARG)
                CONFIG_CLAUDE_ARGS+=("$value")
                ;;
            ANONYMIZED_PATHS)
                CONFIG_ANONYMIZED_PATHS="$value"
                ;;
            USE_NVIDIA)
                CONFIG_USE_NVIDIA="$value"
                ;;
            WORKTREE_MODE)
                CONFIG_WORKTREE_MODE="$value"
                ;;
        esac
    done < "$config_file"
}

# Initialize config arrays
CONFIG_PODMAN_VOLUMES=()
CONFIG_PODMAN_OPTIONS=()
CONFIG_CLAUDE_ARGS=()
CONFIG_ANONYMIZED_PATHS=""
CONFIG_USE_NVIDIA=""
CONFIG_WORKTREE_MODE=""

# Load configuration if available (unless --no-config is passed)
# We need to do a quick check for --no-config before loading
USE_CONFIG=1
for arg in "$@"; do
    if [ "$arg" = "--no-config" ]; then
        USE_CONFIG=0
        break
    fi
done

if [ "$USE_CONFIG" -eq 1 ]; then
    GIT_DIR=$(find_git_dir)
    if [ -n "$GIT_DIR" ]; then
        CONFIG_FILE="$GIT_DIR/yolo/config"
        if [ -f "$CONFIG_FILE" ]; then
            load_config "$CONFIG_FILE"
        fi
    fi
fi

# Parse arguments: everything before -- goes to podman, everything after goes to claude
# Also check for --anonymized-paths, --entrypoint, --worktree, --nvidia, and --no-config flags
PODMAN_ARGS=()
CLAUDE_ARGS=()
found_separator=0
USE_ANONYMIZED_PATHS=${CONFIG_ANONYMIZED_PATHS:-0}
ENTRYPOINT="claude"
WORKTREE_MODE=${CONFIG_WORKTREE_MODE:-ask}
USE_NVIDIA=${CONFIG_USE_NVIDIA:-0}

while [ $# -gt 0 ]; do
    case "$1" in
        -h|--help)
            show_help
            ;;
        --entrypoint)
            ENTRYPOINT="$2"
            shift 2
            ;;
        --entrypoint=*)
            ENTRYPOINT="${1#--entrypoint=}"
            shift
            ;;
        --worktree=*)
            WORKTREE_MODE="${1#--worktree=}"
            # Validate worktree mode
            if [[ ! "$WORKTREE_MODE" =~ ^(ask|bind|skip|error)$ ]]; then
                echo "Error: Invalid --worktree value: $WORKTREE_MODE" >&2
                echo "Valid values are: ask, bind, skip, error" >&2
                exit 1
            fi
            shift
            ;;
        --anonymized-paths)
            USE_ANONYMIZED_PATHS=1
            shift
            ;;
        --nvidia)
            USE_NVIDIA=1
            shift
            ;;
        --no-config)
            # Already handled before config loading, just skip it here
            shift
            ;;
        --)
            shift
            found_separator=1
            CLAUDE_ARGS=("$@")
            break
            ;;
        *)
            if [ "$found_separator" -eq 1 ]; then
                CLAUDE_ARGS+=("$1")
            else
                PODMAN_ARGS+=("$1")
            fi
            shift
            ;;
    esac
done

# Merge config arrays with command line args
# Config values come first, then CLI args (CLI takes precedence for duplicates)
# We need to handle this carefully because of the -- separator logic
CONFIG_PODMAN_ARGS_TO_ADD=()
if [ "$USE_CONFIG" -eq 1 ]; then
    # Prepare volume mounts from config
    for volume in "${CONFIG_PODMAN_VOLUMES[@]}"; do
        CONFIG_PODMAN_ARGS_TO_ADD+=("-v" "$volume")
    done
    
    # Prepare podman options from config
    for option in "${CONFIG_PODMAN_OPTIONS[@]}"; do
        CONFIG_PODMAN_ARGS_TO_ADD+=("$option")
    done
    
    # Add claude args from config (these go at the end, before CLI claude args)
    if [ ${#CONFIG_CLAUDE_ARGS[@]} -gt 0 ]; then
        CLAUDE_ARGS=("${CONFIG_CLAUDE_ARGS[@]}" "${CLAUDE_ARGS[@]}")
    fi
fi

if [ "$found_separator" = 0 ]; then
    # so we did not find any -- everything from PODMAN_ARGS is actually CLAUDE_ARGS
    # Append them to any existing CLAUDE_ARGS (from config)
    CLAUDE_ARGS=("${CLAUDE_ARGS[@]}" "${PODMAN_ARGS[@]}")
    PODMAN_ARGS=()
fi

# Now add config podman args (after the separator logic)
if [ "$USE_CONFIG" -eq 1 ] && [ ${#CONFIG_PODMAN_ARGS_TO_ADD[@]} -gt 0 ]; then
    PODMAN_ARGS=("${CONFIG_PODMAN_ARGS_TO_ADD[@]}" "${PODMAN_ARGS[@]}")
fi

# Give a meaningful name based on PWD and the PID to help identifying
# all those podman containers
# Note: leading periods and underscores are stripped as they're not allowed in container names
name=$( echo "$PWD-$$" | sed -e "s,^$HOME/,,g" -e "s,[^a-zA-Z0-9_.-],_,g" -e "s,^[._]*,," )

CLAUDE_HOME_DIR="$HOME/.claude"
# must exist but might not if first start on that box
mkdir -p "$CLAUDE_HOME_DIR"

# Detect if we're in a git worktree and find the original repo
WORKTREE_MOUNTS=()
gitdir_path=""
dot_git="$(pwd)/.git"
is_worktree=0
original_repo_dir=""

if [ -L "$dot_git" ]; then
    # .git is a symlink - resolve it to get the gitdir path
    gitdir_path=$(realpath "$dot_git" 2>/dev/null)
elif [ -f "$dot_git" ]; then
    # .git is a file, likely a worktree - read the gitdir path
    gitdir_line=$(cat "$dot_git")
    if [[ "$gitdir_line" =~ ^gitdir:\ (.+)$ ]]; then
        gitdir_path="${BASH_REMATCH[1]}"
        # Resolve to absolute path if relative
        if [[ "$gitdir_path" != /* ]]; then
            gitdir_path="$(pwd)/$gitdir_path"
        fi
        gitdir_path=$(realpath "$gitdir_path" 2>/dev/null || echo "$gitdir_path")
    fi
fi

if [ -n "$gitdir_path" ]; then
    # gitdir_path is typically /path/to/original/repo/.git/worktrees/<name>
    # We need to find the original repo's .git directory
    if [[ "$gitdir_path" =~ ^(.+/\.git)/worktrees/ ]]; then
        original_git_dir="${BASH_REMATCH[1]}"
        original_repo_dir=$(dirname "$original_git_dir")
        # Only consider it a worktree if it's different from our current workspace
        if [ "$original_repo_dir" != "$(pwd)" ]; then
            is_worktree=1
        fi
    fi
fi

# Handle worktree based on the mode
if [ "$is_worktree" -eq 1 ]; then
    case "$WORKTREE_MODE" in
        error)
            echo "Error: Running in a git worktree is not allowed with --worktree=error" >&2
            echo "Original repo: $original_repo_dir" >&2
            exit 1
            ;;
        bind)
            WORKTREE_MOUNTS+=("-v" "$original_repo_dir:$original_repo_dir:Z")
            ;;
        skip)
            # Do nothing - skip bind mount
            ;;
        ask)
            echo "Detected git worktree. Original repository: $original_repo_dir" >&2
            echo "Bind mounting the original repo allows git operations but may expose unintended files." >&2
            read -p "Bind mount original repository? [y/N] " -n 1 -r >&2
            echo >&2
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                WORKTREE_MOUNTS+=("-v" "$original_repo_dir:$original_repo_dir:Z")
            fi
            ;;
    esac
fi

# Determine paths based on --anonymized-paths flag
if [ "$USE_ANONYMIZED_PATHS" -eq 1 ]; then
    # Old behavior: use anonymized paths
    CLAUDE_DIR="/claude"
    WORKSPACE_DIR="/workspace"
    CLAUDE_MOUNT="$CLAUDE_HOME_DIR:/claude:Z"
    WORKSPACE_MOUNT="$(pwd):/workspace:Z"
else
    # New default behavior: preserve original host paths
    CLAUDE_DIR="$CLAUDE_HOME_DIR"
    WORKSPACE_DIR="$(pwd)"
    CLAUDE_MOUNT="$CLAUDE_HOME_DIR:$CLAUDE_HOME_DIR:Z"
    WORKSPACE_MOUNT="$(pwd):$(pwd):Z"
fi

# Build the command to run inside the container
if [ "$ENTRYPOINT" = "claude" ]; then
    # Default: run claude with --dangerously-skip-permissions
    CONTAINER_CMD=("claude" "--dangerously-skip-permissions" "${CLAUDE_ARGS[@]}")
else
    # Custom entrypoint: run as-is with any additional args
    CONTAINER_CMD=("$ENTRYPOINT" "${CLAUDE_ARGS[@]}")
fi

# NVIDIA GPU support via CDI (Container Device Interface)
# Requires nvidia-container-toolkit on host with CDI spec generated
NVIDIA_ARGS=()
if [ "$USE_NVIDIA" -eq 1 ]; then
    # Check if CDI spec exists
    if [ ! -f /etc/cdi/nvidia.yaml ] && [ ! -f /var/run/cdi/nvidia.yaml ]; then
        echo "Warning: NVIDIA CDI spec not found at /etc/cdi/nvidia.yaml or /var/run/cdi/nvidia.yaml" >&2
        echo "GPU passthrough may not work. Install nvidia-container-toolkit and run:" >&2
        echo "  sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml" >&2
        echo >&2
    fi
    NVIDIA_ARGS+=(--device "nvidia.com/gpu=all")
    NVIDIA_ARGS+=(--security-opt "label=disable")
fi

podman run --log-driver=none -it --rm \
    --user="$(id -u):$(id -g)"\
    --userns=keep-id \
    --name="$name" \
    -v "$CLAUDE_MOUNT" \
    -v "$HOME/.gitconfig:/tmp/.gitconfig:ro,Z" \
    -v "$WORKSPACE_MOUNT" \
    "${WORKTREE_MOUNTS[@]}" \
    -w "$WORKSPACE_DIR" \
    -e CLAUDE_CONFIG_DIR="$CLAUDE_DIR" \
    -e GIT_CONFIG_GLOBAL=/tmp/.gitconfig \
    -e CLAUDE_CODE_OAUTH_TOKEN \
    "${NVIDIA_ARGS[@]}" \
    "${PODMAN_ARGS[@]}" \
    con-bomination-claude-code \
    "${CONTAINER_CMD[@]}"
