#!/bin/bash
# Claude Code YOLO mode - auto-approve all actions in containerized environment

set -e

show_help() {
    cat << 'EOF'
Usage: yolo [OPTIONS] [-- CLAUDE_ARGS...]

Run Claude Code in YOLO mode (auto-approve all actions) inside a container.

OPTIONS:
    -h, --help          Show this help message
    --anonymized-paths  Use anonymized paths (/claude, /workspace) instead of
                        preserving host paths
    --entrypoint=CMD    Override the container entrypoint (default: claude)
    --worktree=MODE     Git worktree handling: ask, bind, skip, error
                        (default: ask)
    --nvidia            Enable NVIDIA GPU passthrough via CDI
                        Requires nvidia-container-toolkit on host

    Additional podman options can be passed before --

EXAMPLES:
    yolo                              # Basic usage
    yolo --nvidia                     # With GPU support
    yolo -v /data:/data               # Extra mount
    yolo -- "help with this code"     # Pass args to claude
    yolo --nvidia -- --resume         # GPU + claude args

NVIDIA GPU SETUP:
    The --nvidia flag uses CDI (Container Device Interface) for GPU access.
    Prerequisites:
    1. Install nvidia-container-toolkit on your host
    2. Generate CDI spec: sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml
    3. Use: yolo --nvidia

EOF
    exit 0
}

# Parse arguments: everything before -- goes to podman, everything after goes to claude
# Also check for --anonymized-paths, --entrypoint, --worktree, and --nvidia flags
PODMAN_ARGS=()
CLAUDE_ARGS=()
found_separator=0
USE_ANONYMIZED_PATHS=0
ENTRYPOINT="claude"
WORKTREE_MODE="ask"
USE_NVIDIA=0

while [ $# -gt 0 ]; do
    case "$1" in
        -h|--help)
            show_help
            ;;
        --entrypoint)
            ENTRYPOINT="$2"
            shift 2
            ;;
        --entrypoint=*)
            ENTRYPOINT="${1#--entrypoint=}"
            shift
            ;;
        --worktree=*)
            WORKTREE_MODE="${1#--worktree=}"
            # Validate worktree mode
            if [[ ! "$WORKTREE_MODE" =~ ^(ask|bind|skip|error)$ ]]; then
                echo "Error: Invalid --worktree value: $WORKTREE_MODE" >&2
                echo "Valid values are: ask, bind, skip, error" >&2
                exit 1
            fi
            shift
            ;;
        --anonymized-paths)
            USE_ANONYMIZED_PATHS=1
            shift
            ;;
        --nvidia)
            USE_NVIDIA=1
            shift
            ;;
        --)
            shift
            found_separator=1
            CLAUDE_ARGS=("$@")
            break
            ;;
        *)
            if [ "$found_separator" -eq 1 ]; then
                CLAUDE_ARGS+=("$1")
            else
                PODMAN_ARGS+=("$1")
            fi
            shift
            ;;
    esac
done

if [ "$found_separator" = 0 ]; then
    # so we did not find any -- everything is actually CLAUDE_ARGS
    CLAUDE_ARGS=("${PODMAN_ARGS[@]}")
    PODMAN_ARGS=()
fi

# Give a meaningful name based on PWD and the PID to help identifying
# all those podman containers
# Note: leading periods and underscores are stripped as they're not allowed in container names
name=$( echo "$PWD-$$" | sed -e "s,^$HOME/,,g" -e "s,[^a-zA-Z0-9_.-],_,g" -e "s,^[._]*,," )

CLAUDE_HOME_DIR="$HOME/.claude"
# must exist but might not if first start on that box
mkdir -p "$CLAUDE_HOME_DIR"

# Detect if we're in a git worktree and find the original repo
WORKTREE_MOUNTS=()
gitdir_path=""
dot_git="$(pwd)/.git"
is_worktree=0
original_repo_dir=""

if [ -L "$dot_git" ]; then
    # .git is a symlink - resolve it to get the gitdir path
    gitdir_path=$(realpath "$dot_git" 2>/dev/null)
elif [ -f "$dot_git" ]; then
    # .git is a file, likely a worktree - read the gitdir path
    gitdir_line=$(cat "$dot_git")
    if [[ "$gitdir_line" =~ ^gitdir:\ (.+)$ ]]; then
        gitdir_path="${BASH_REMATCH[1]}"
        # Resolve to absolute path if relative
        if [[ "$gitdir_path" != /* ]]; then
            gitdir_path="$(pwd)/$gitdir_path"
        fi
        gitdir_path=$(realpath "$gitdir_path" 2>/dev/null || echo "$gitdir_path")
    fi
fi

if [ -n "$gitdir_path" ]; then
    # gitdir_path is typically /path/to/original/repo/.git/worktrees/<name>
    # We need to find the original repo's .git directory
    if [[ "$gitdir_path" =~ ^(.+/\.git)/worktrees/ ]]; then
        original_git_dir="${BASH_REMATCH[1]}"
        original_repo_dir=$(dirname "$original_git_dir")
        # Only consider it a worktree if it's different from our current workspace
        if [ "$original_repo_dir" != "$(pwd)" ]; then
            is_worktree=1
        fi
    fi
fi

# Handle worktree based on the mode
if [ "$is_worktree" -eq 1 ]; then
    case "$WORKTREE_MODE" in
        error)
            echo "Error: Running in a git worktree is not allowed with --worktree=error" >&2
            echo "Original repo: $original_repo_dir" >&2
            exit 1
            ;;
        bind)
            WORKTREE_MOUNTS+=("-v" "$original_repo_dir:$original_repo_dir:Z")
            ;;
        skip)
            # Do nothing - skip bind mount
            ;;
        ask)
            echo "Detected git worktree. Original repository: $original_repo_dir" >&2
            echo "Bind mounting the original repo allows git operations but may expose unintended files." >&2
            read -p "Bind mount original repository? [y/N] " -n 1 -r >&2
            echo >&2
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                WORKTREE_MOUNTS+=("-v" "$original_repo_dir:$original_repo_dir:Z")
            fi
            ;;
    esac
fi

# Determine paths based on --anonymized-paths flag
if [ "$USE_ANONYMIZED_PATHS" -eq 1 ]; then
    # Old behavior: use anonymized paths
    CLAUDE_DIR="/claude"
    WORKSPACE_DIR="/workspace"
    CLAUDE_MOUNT="$CLAUDE_HOME_DIR:/claude:Z"
    WORKSPACE_MOUNT="$(pwd):/workspace:Z"
else
    # New default behavior: preserve original host paths
    CLAUDE_DIR="$CLAUDE_HOME_DIR"
    WORKSPACE_DIR="$(pwd)"
    CLAUDE_MOUNT="$CLAUDE_HOME_DIR:$CLAUDE_HOME_DIR:Z"
    WORKSPACE_MOUNT="$(pwd):$(pwd):Z"
fi

# Build the command to run inside the container
if [ "$ENTRYPOINT" = "claude" ]; then
    # Default: run claude with --dangerously-skip-permissions
    CONTAINER_CMD=("claude" "--dangerously-skip-permissions" "${CLAUDE_ARGS[@]}")
else
    # Custom entrypoint: run as-is with any additional args
    CONTAINER_CMD=("$ENTRYPOINT" "${CLAUDE_ARGS[@]}")
fi

# NVIDIA GPU support via CDI (Container Device Interface)
# Requires nvidia-container-toolkit on host with CDI spec generated
NVIDIA_ARGS=()
if [ "$USE_NVIDIA" -eq 1 ]; then
    # Check if CDI spec exists
    if [ ! -f /etc/cdi/nvidia.yaml ] && [ ! -f /var/run/cdi/nvidia.yaml ]; then
        echo "Warning: NVIDIA CDI spec not found at /etc/cdi/nvidia.yaml or /var/run/cdi/nvidia.yaml" >&2
        echo "GPU passthrough may not work. Install nvidia-container-toolkit and run:" >&2
        echo "  sudo nvidia-ctk cdi generate --output=/etc/cdi/nvidia.yaml" >&2
        echo >&2
    fi
    NVIDIA_ARGS+=(--device "nvidia.com/gpu=all")
    NVIDIA_ARGS+=(--security-opt "label=disable")
fi

podman run --log-driver=none -it --rm \
    --user="$(id -u):$(id -g)"\
    --userns=keep-id \
    --name="$name" \
    -v "$CLAUDE_MOUNT" \
    -v "$HOME/.gitconfig:/tmp/.gitconfig:ro,Z" \
    -v "$WORKSPACE_MOUNT" \
    "${WORKTREE_MOUNTS[@]}" \
    -w "$WORKSPACE_DIR" \
    -e CLAUDE_CONFIG_DIR="$CLAUDE_DIR" \
    -e GIT_CONFIG_GLOBAL=/tmp/.gitconfig \
    "${NVIDIA_ARGS[@]}" \
    "${PODMAN_ARGS[@]}" \
    con-bomination-claude-code \
    "${CONTAINER_CMD[@]}"
